HEADER = '''\
# cython: language_level=3
# DO NOT EDIT THIS FILE.
# This file was generated from generator.py


cdef extern from "<stdatomic.h>":
    int memory_order_relaxed
    int memory_order_consume
    int memory_order_acquire
    int memory_order_release
    int memory_order_acq_rel
    int memory_order_seq_cst


MEMORY_ORDER_RELAXED = memory_order_relaxed
MEMORY_ORDER_CONSUME = memory_order_consume
MEMORY_ORDER_ACQUIRE = memory_order_acquire
MEMORY_ORDER_RELEASE = memory_order_release
MEMORY_ORDER_ACQ_REL = memory_order_acq_rel
MEMORY_ORDER_SEQ_CST = memory_order_seq_cst
'''

PER_INT_TYPE = '''\
from libc.stdint cimport $INT_TYPE


cdef extern from "<stdatomic.h>":
    bint ${INT_TYPE}_is_lock_free "atomic_is_lock_free" (${INT_TYPE}*)
    void ${INT_TYPE}_store_explicit "atomic_store_explicit" (${INT_TYPE}*, ${INT_TYPE}, int)
    ${INT_TYPE} ${INT_TYPE}_load_explicit "atomic_load_explicit" (${INT_TYPE}*, int)
    ${INT_TYPE} ${INT_TYPE}_exchange_explicit "atomic_exchange_explicit" (${INT_TYPE}*, ${INT_TYPE}, int)
    bint ${INT_TYPE}_compare_exchange_strong_explicit "atomic_compare_exchange_strong_explicit" (${INT_TYPE}*, ${INT_TYPE}*, ${INT_TYPE}, int, int)
    bint ${INT_TYPE}_compare_exchange_weak_explicit "atomic_compare_exchange_weak_explicit" (${INT_TYPE}*, ${INT_TYPE}*, ${INT_TYPE}, int, int)
    ${INT_TYPE} ${INT_TYPE}_fetch_add_explicit "atomic_fetch_add_explicit" (${INT_TYPE}*, ${INT_TYPE}, int)
    ${INT_TYPE} ${INT_TYPE}_fetch_sub_explicit "atomic_fetch_sub_explicit" (${INT_TYPE}*, ${INT_TYPE}, int)
    ${INT_TYPE} ${INT_TYPE}_fetch_and_explicit "atomic_fetch_and_explicit" (${INT_TYPE}*, ${INT_TYPE}, int)
    ${INT_TYPE} ${INT_TYPE}_fetch_or_explicit "atomic_fetch_or_explicit" (${INT_TYPE}*, ${INT_TYPE}, int)
    ${INT_TYPE} ${INT_TYPE}_fetch_xor_explicit "atomic_fetch_xor_explicit" (${INT_TYPE}*, ${INT_TYPE}, int)


cdef class _${INT_TYPE}:
    cdef object memory
    cdef ${INT_TYPE}* ptr

    def __cinit__(self, unsigned char[:] memory):
        if len(memory) != sizeof(${INT_TYPE}):
            raise ValueError("length must be 1")
        self.memory = memory
        self.ptr = <${INT_TYPE}*>&memory[0]
        if not ${INT_TYPE}_is_lock_free(self.ptr):
            raise ValueError("memory is not aligned for lock-free access")

    def load(self, memory_order=memory_order_seq_cst):
        return ${INT_TYPE}_load_explicit(self.ptr, memory_order)

    def store(self, value, memory_order=memory_order_seq_cst):
        ${INT_TYPE}_store_explicit(self.ptr, value, memory_order)

    def exchange(self, value, memory_order=memory_order_seq_cst):
        return ${INT_TYPE}_exchange_explicit(self.ptr, value, memory_order)

    def compare_exchange_weak(self, expected, desired,
                              memory_order_success=memory_order_seq_cst,
                              memory_order_failure=memory_order_seq_cst):
        cdef ${INT_TYPE} c_expected = expected
        ret = ${INT_TYPE}_compare_exchange_weak_explicit(self.ptr,
                                                         &c_expected,
                                                         desired,
                                                         memory_order_success,
                                                         memory_order_failure)
        return (ret, c_expected)

    def compare_exchange_strong(self, expected, desired,
                                memory_order_success=memory_order_seq_cst,
                                memory_order_failure=memory_order_seq_cst):
        cdef ${INT_TYPE} c_expected = expected
        ret = ${INT_TYPE}_compare_exchange_strong_explicit(self.ptr,
                                                           &c_expected,
                                                           desired,
                                                           memory_order_success,
                                                           memory_order_failure)
        return (ret, c_expected)

    def fetch_add(self, value, memory_order=memory_order_seq_cst):
        return ${INT_TYPE}_fetch_add_explicit(self.ptr, value, memory_order)

    def fetch_sub(self, value, memory_order=memory_order_seq_cst):
        return ${INT_TYPE}_fetch_sub_explicit(self.ptr, value, memory_order)

    def fetch_and(self, value, memory_order=memory_order_seq_cst):
        return ${INT_TYPE}_fetch_and_explicit(self.ptr, value, memory_order)

    def fetch_or(self, value, memory_order=memory_order_seq_cst):
        return ${INT_TYPE}_fetch_or_explicit(self.ptr, value, memory_order)

    def fetch_xor(self, value, memory_order=memory_order_seq_cst):
        return ${INT_TYPE}_fetch_xor_explicit(self.ptr, value, memory_order)
'''

FOOTER = '''
class _DelegateToImplMixin:
    def __int__(self):
        return self._impl.load()

    def __iadd__(self, value):
        self._impl.fetch_add(value)
        return self

    def __isub__(self, value):
        self._impl.fetch_add(value)
        return self

    def __iand__(self, value):
        self._impl.fetch_and(value)
        return self

    def __ior__(self, value):
        self._impl.fetch_or(value)
        return self

    def __ixor__(self, value):
        self._impl.fetch_xor(value)
        return self

    def load(self, memory_order=memory_order_seq_cst):
        return self._impl.load(memory_order)

    def store(self, value, memory_order=memory_order_seq_cst):
        return self._impl.store(value, memory_order)

    def exchange(self, value, memory_order=memory_order_seq_cst):
        return self._impl.exchange(value, memory_order)

    def compare_exchange_weak(self, expected, desired,
                              memory_order_success=memory_order_seq_cst,
                              memory_order_failure=memory_order_seq_cst):
        return self._impl.compare_exchange_weak(expected,
                                                desired,
                                                memory_order_success,
                                                memory_order_failure)

    def compare_exchange_strong(self, expected, desired,
                                memory_order_success=memory_order_seq_cst,
                                memory_order_failure=memory_order_seq_cst):
        return self._impl.compare_exchange_strong(expected,
                                                  desired,
                                                  memory_order_success,
                                                  memory_order_failure)

    def fetch_add(self, value, memory_order=memory_order_seq_cst):
        return self._impl.fetch_add(value, memory_order)

    def fetch_sub(self, value, memory_order=memory_order_seq_cst):
        return self._impl.fetch_sub(value, memory_order)

    def fetch_and(self, value, memory_order=memory_order_seq_cst):
        return self._impl.fetch_and(value, memory_order)

    def fetch_or(self, value, memory_order=memory_order_seq_cst):
        return self._impl.fetch_or(value, memory_order)

    def fetch_xor(self, value, memory_order=memory_order_seq_cst):
        return self._impl.fetch_xor(value, memory_order)


class Uint(_DelegateToImplMixin):
    def __init__(self, memory):
        if len(memory) == 1:
            self._impl = _uint8_t(memory)
        elif len(memory) == 2:
            self._impl = _uint16_t(memory)
        elif len(memory) == 4:
            self._impl = _uint32_t(memory)
        elif len(memory) == 8:
            self._impl = _uint64_t(memory)
        else:
            raise ValueError("Length must be 1, 2, 4, or 8 bytes.")


class Int(_DelegateToImplMixin):
    def __init__(self, memory):
        if len(memory) == 1:
            self._impl = _int8_t(memory)
        elif len(memory) == 2:
            self._impl = _int16_t(memory)
        elif len(memory) == 4:
            self._impl = _int32_t(memory)
        elif len(memory) == 8:
            self._impl = _int64_t(memory)
        else:
            raise ValueError("Length must be 1, 2, 4, or 8 bytes.")
'''
